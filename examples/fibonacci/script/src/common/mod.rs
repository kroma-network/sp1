use std::sync::Arc;

use anyhow::Result;
use p3_challenger::CanObserve;
use sp1_core::{
    runtime::Program,
    stark::{Challenger, MachineProver, StarkGenericConfig},
    utils::{SP1CoreOpts, SP1ProverOpts},
};
use sp1_prover::{
    components::DefaultProverComponents,
    types::{SP1ProvingKey, SP1VerifyingKey},
    SP1CoreProof,
};
use sp1_sdk::{
    action, InnerSC, ProverClient, SP1Context, SP1ContextBuilder, SP1ProofKind, SP1Prover, SP1Stdin,
};
use sysinfo::System;

use crate::ProveArgs;

/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.
///
/// This file is generated by running `cargo prove build` inside the `program` directory.
pub const FIBONACCI_ELF: &[u8] = include_bytes!("../../../program/elf/riscv32im-succinct-zkvm-elf");

pub fn init_client(args: ProveArgs) -> (ProverClient, SP1Stdin, SP1ProvingKey, SP1VerifyingKey) {
    let client = ProverClient::new();
    let (pk, vk) = client.setup(FIBONACCI_ELF);
    let mut stdin = SP1Stdin::new();
    stdin.write(&args.n);

    (client, stdin, pk, vk)
}

pub fn bootstrap<'a>(
    client: &'a ProverClient,
    pk: &SP1ProvingKey,
) -> Result<(Program, SP1CoreOpts, SP1Context<'a>)> {
    let kind = SP1ProofKind::default();
    let core_opts = SP1CoreOpts::default();

    let mut context_builder = SP1ContextBuilder::default();
    let mut context = context_builder.build();

    // prove function in local.rs
    // Operator only.
    let total_ram_gb = System::new_all().total_memory() / 1_000_000_000;
    if kind == SP1ProofKind::Plonk && total_ram_gb <= 120 {
        return Err(anyhow::anyhow!(
            "not enough memory to generate plonk proof. at least 128GB is required."
        ));
    };

    context
        .subproof_verifier
        .get_or_insert_with(|| Arc::new(client.prover.sp1_prover()));

    // prove core function in local.rs
    let program = Program::from(pk.elf.as_slice());

    Ok((program, core_opts, context))
}

pub fn get_leaf_challenger(
    client: &ProverClient,
    vk: &SP1VerifyingKey,
    proof: SP1CoreProof,
) -> Challenger<InnerSC> {
    let shard_proofs = &proof.proof.0;

    let mut leaf_challenger = client.prover.sp1_prover().core_prover.config().challenger();
    vk.vk.observe_into(&mut leaf_challenger);
    shard_proofs.iter().for_each(|proof| {
        leaf_challenger.observe(proof.commitment.main_commit);
        leaf_challenger.observe_slice(
            &proof.public_values[0..client.prover.sp1_prover().core_prover.num_pv_elts()],
        );
    });
    leaf_challenger
}
